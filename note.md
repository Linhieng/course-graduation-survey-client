# 重构 ing

## 实现国际化

实现国际化

安装 vue-i18n
创建 src\locale\index.ts
    在其中返回一个 createI18n 对象
    createI18n 对象中的  messages 就是具体的语言类型。
    通常会在每个 view 中单独创建一个 '@/views/login/locale/zh-CN' 然后统一在 src\locale\zh-CN.ts 中导入和导出，也就是将所有 locale 中的文本到放到 createI18n 对象中的  messages  里面。
在 main.ts 到 use
    import i18n from './locale'
    app.use(i18n)
组件中使用
    组件中可以直接使用 $t('') 获取文本
编程式使用
    import { useI18n } from 'vue-i18n'
    const i18 = useI18n()
    i18.t('navbar.action.locale')

实现语言切换
    使用一个 src\hooks\locale.ts
    在里面返回一个 useLocale 函数
    函数返回一个 changeLocale 函数和一个属性 currentLocale

i18n 只能用在 setup 中，在 hook 中或者 api 函数中都是无效的。
但我确实想要在 axios 拦截请求时使用国际化，怎么弄？

分析原因，之所以只能在 setup 中使用，是因为我调用的是 useI18n。
而 useI18n 只能在 setup 中使用。

想要解决，那么就是不使用 useI18n，而是直接获取到 i18n 对象。
下面代码就可以解决问题：
    import i18n from '@/locale'
    const {t} = i18n.global




## 使用 loading

通过创建一个 src\hooks\loading.ts 文件，来使用加载状态，这个 hooks 返回
- loading 属性
- setLoading 方法
- toggle 方法

## 登录功能的实现

表单，校验、loading。
组件中负责校验。
store 中负责登录逻辑，同时将 token 存储在 localStorage 中。

setToken 和 getToken 放在 src\utils\auth.ts 文件中。他返回四个方法
    isLogin, getToken, setToken, clearToken

logout 的逻辑，拆分到 hook/useUser 和 store 中的 logout。
在 store 中只专注于数据的处理，hook/useUser 类似于一个调度人。

使用 mock 模拟登录后的数据
    安装 mockjs
    在 main.ts 中导入 mock
    创建 mock 文件夹！
    保证 mock 的 setup，实现简单的 mock 开关


## axios 封装

acro-design-pro-vue 组件中的 axios 实际上并没有封装。因为他在每个 api 中都直接获取了 axios 对象，仅仅只是在 interceptor.ts 中进行了拦截，所以实际的封装还是需要我们自己来。不过他确实给我提供了参考。

我现在有了新的封装思路，是这样的：
- 在 axios.ts 中新建一个 axios 实例，然后我们后续的所有请求都将在这个实例上面进行处理
- interceptor.ts 文件中返回两个拦截函数，分别对请求和响应进行拦截。他们都接收一个 axios 实际对象。
- 然后，暂时不推荐将所以 api 都通过 index.ts 导出，原因是电脑太差了，统一导出时 vscode 并没办法快速给出对应的类型，这违背了我使用 index.ts 统一导出的初衷——方便。而且，我的文件名基本不会改变。
- 每一个 api 还是通过 axios.ts 获取 get 和 post，只不过这一次他们的类型不再是之前那样。这一次重构，我发现可以直接在 axios.ts 中的 get 和 post 中指定返回类型为 `Promise<HttpResponse<T>>`，然后在实际使用时，只需一次 `return get<T>` 就可以直接获取到内容了。这比起之前那种封装类型的方式好太多了！
- 此外，api 的类型不需要再写在 types 文件中了。原因是我发现统一写在 types 中并没有带来多大的便利，直接写在对应文件夹中挺好的，别人看也能直接看到，不需要跳转（还是那个原因，vscode 太卡了）

## vue use

使用 useStorage 可以自动响应 localStorage。
可以通过 storage.value.xx 获取值
也可以通过 storage.xx 直接获取响应式，用于 v-model

useFullscreen 切换全屏

useWindowSize 获取窗口大小，也就是媒体查询！

# 笔记

TODO:

- [ ] CI/CD, git action
- [ ] 国际化
- [ ] 换肤
- [x] 使用 token
- [ ] ~~使用 session~~ 使用 localSotrage 存储 token，然后使用 axios 拦截，在每次请求前填充 token，具体细节参考 [arco-design-pro-vue]
- [ ] 使用 pinia 进行单个页面的全局管理，不在组件中进行通信
- [ ] 修复相关样式问题（优先级低）
- [ ] 重构代码，让其逻辑更加清晰
- [ ] 重构类型，让其更易读（优先级极低，且需要考虑的事情极多！）
- [x] 拆分SurveyQuestion 类型 A|B
- [ ] 提供 dev 环境下的内容输出
- [x] 将文本编辑框抽离处理，与 store 解耦
- [ ] 对问题的增删，抽离到一个 NewOptions 组件中
- [ ] 重命名相关组件名称，让其更易读和有规律。
- [ ] 重命名类型和常量名，让其更加易读和有规律！
- [x] 处理问卷的缓存
- [ ] 提供对 PC 端的宽度适应，比如让工具直接显示在一旁，无需隐藏，但在 phone 中就隐藏为按钮
- [ ] 重新封装 axios，参考 [arco-design-pro-vue] 中的封装方式，使用拦截器进行封装！
- [ ] 使用 localStorage 缓存用户输入的答案！
- [ ] 监听用户从进入问卷，到提交问卷的总时长


## 自问自答

- 思考：完成必选校验后，如何搭配提交

每个组件自己负责自己的必选问题，然后将情况报告给 store。这种方式实现起来脉络清晰，而且也不容易出错。
但这仅仅是校验，当单纯提交时，如果校验成功，该如何处理呢？

这本应该是一个很简单的问题，用户点击 --> 校验 --> 成功则提交。

但现在变得有些复杂了，原因在于“校验”这一步变成了异步的！而且每一个问题都是独自进行校验。
你需要在什么时候才能够知道所有问题都校验成功了呢？

如果继续朝着“判断何时才算校验结束”这个方向思考，那么问题就会变得复杂，但如果换个角度思考，就简单了。
异步的复杂，那我们换成同步的不就可以了！

这个时候你可能就想掀起桌子骂人了，刚刚还在用异步校验必选呢？
你这又打算变成同步？那校验不就变得复杂了吗？

非也非也，只要消耗一点性能，那么就可以让问题变得简单！我们可以在 store 中进行一个总体的校验，当遇到一个
还没有添加答案的问题时，就调用 checkAnswer，将剩下的校验工作交给组件们自己去处理。而如果一路校验通畅，
那么就可以直接提交了！

这场景像极了班主任，班主任要提交班级作业时，首先她会自己先一份一份检查，而如果一旦发现有一份不合格，那么她就直接
全部打回，让全部同学重新检查一遍！而如果没有问题，那就不需要打回，直接就提交了！

妙呀妙呀，我都佩服我自己！可以看出我进步了，思维更灵活了。因为以前做问题系统时，这一块可是很让我束手无措的。当时
的思路一点也不清晰。

- 思考：填写问卷时，如何进行必选校验

为什么要思考这个呢？因为我的添加问卷界面同样分了很多组件，每一类问题都由一个特定的组件进行渲染。
这种开发方式让我很容易理解 DOM 结构树，而且我相信别人看到我这代码时，也会很容易理解 DOM 的结构。

但问题就在于，DOM 是划分的好了，但是表单校验是一个问题！

抽象上看，整体的流程是这样的：
1. 用户点击提交
2. js 校验哪些必选的问题没有填写
3. js 通知用户某些问题没有添加，同时，还应该能够让页面滚动到对应位置

目前，先不考虑滚动问题，先确保问题的必选。由于前面的经验，一个页面的数据我会将它全部交给
store 进行统一管理，所以，当点击提交时，也应该由 store 进行统一管理，同时进行数据的校验。
但发现每个问题没有内容时，就应该能够通过某种方式通知到对应的组件。

我觉得这里应该使用广播的时候，也就是说，store 会将还未添加的问题的 id 进行广播。
然后每个组件都会接收这个广播，然后看看是不是自己的锅。如果是，那么该组件就应该以某种方式提醒用户。
组件通知的方式可以通过弹出一个消息来实现。

但如果有很多问题，用户全部都没添加，那此时岂不是会弹出非常非常多的消息？所以这种方式不可取。
虽然可以想到用优先级处理，也就是当有一个组件弹出消息后，那么其他组件就不能弹出消息了。
但这种方式方式我觉得有点复杂了，杀鸡焉用牛刀。

算了，先不想那么多，总之，现在应该先实现一个机制，让组件能够知道当前它所负责的问题还未被添加。

其实，除了让 store 广播 id 外，还有一种方式能够实现：那就是发送一个提交事件给所有组件，然后
每个组件自己进行内容是否已经填写。如果未填写，则通知用户，同时也将这个消息报告给 store。
而 store 就能够收到所有还未填写的组件，然后实际的消息也由 store 负责发布。

经过上面的思考，这个过程其实和现实的很多地方是很像的。store 就是中枢，每一个组件就是对应的底层。

- 聊聊 element-plus

可以说，使用 vue 进行开发，很大程度上是为了使用 vue 的相关生态，而不是使用 vue。
element-plus 就是其中最重要的一个生态之一。目前看来，我对 element-plus 的最主要需求其实是：

- msg 和 notice，这两个可以将 log 信息直接显示给用户。
- 表单相关组件，比如输入框，开关等，虽然有问题，但相比自己开发还是快了很多。

- vue 开发的痛点

vue 注意提供了组件化开发，组件化开发对于页面样式的划分很有用，但是每个组件之间的数据通信则变得复杂起来了。
比如一个创建问卷的页面，目前的页面内容其实很简单，但里面却包含了 10 个以上的组件，单纯从 UI 上来看，组件
划分地越多，其实并不影响什么，甚至有利于阅读，但一旦设计到数据，那就变得很复杂了。

原本，这一个页面上只需要一个总的 survey 对象，其他的所有页面模块都是对 survey 中的每一部分进行操作，
这个时候完全不需要考虑同步异步问题，但使用了 vue 后，这一个 survey 就变得七零八碎了。

所以，后续的工作应该是优化这一块内容，目前这一块内容还存在许多 bug，级别都是数据通信之间惹的祸。

具体的解决方案，目前我的想法时，统一使用 pinia 进行管理，虽然这还是有些复杂，但至少能给减少 bug 的存在。
当然，一切还得实践后才知晓答案。

- bug: 为什么根据 v-for 渲染列表时，vue 总在最后插入元素，明明我是使用 splice 在中间插入一个新元素。

场景：想要根据一个数组 question_arr 响应式渲染若干个 question 元素。
此时，如果你使用下标，或者使用元素中的 order 作为 key 的话，那么当你在中间插入一个元素时，
vue 只会认为你在最后添加了一个新元素，所以只在最后面新建一个结点，而不是在中间新建一个结点。
所以，对于会改变顺序的列表，不要使用下标作为 key！

- 封装 axios 的目的所在

在对 axios 进行封装，目的是为了统一所有请求的数据，不管请求是成功也好，失败（比如断网）也罢，最终返回的都是一个统一的对象。也就是说，组件在调用这些请求 api 时，不需要考虑该 api 可能抛出错误，从而让组件代码编写更加方便。

<!-- 思考：应该将服务端中的未知错误，在 axios 中统一捕获？

但 vue 中始终是需要处理错误的，那么可以提供一个未知错误类型，当出现位置错误时，由 axios 进行处理，然后封装好信息返回给 vue 组件的使用，然后每个 vue 组件在使用 api 之前，都应该先判断一下是否是未知错误？这样子似乎很有很多重复代码！

那这样子。后端开发中，想要捕获所以错误的目的是不让程序因为报错而直接奔溃，但前端不存在这个问题。前端中捕获错误的目的是为了给用户友好的提示。所以可以直接在 axios 中提供友好的用户提示（借助 element-plus 的 message）。但问题是，前端中的代码始终是需要往下执行的，所以即使在 axios 中统一捕获错误了，而且给出友好提示了，那么 vue 中的代码还是需要判断一下是否有返回值，这不也算是重复的代码吗？

也许可以新建一个工具类，前端 vue 中需要调用 api 时，使用通过这个工具类来调用，这样能够保证前端的代码中只需要对理想情况进行负责。 -->

## 规范

代码问题（未确定）

- 对 api 的处理，相关错误处理应该直接在 vue 文件中。
- 对于异步操作，同时使用 async + await
- 组件之间的事件传递中，始终使用一个对象。也就是下面这样
    ```ts
    defineEmits<{
        (e: 'event', payload: {...}): void
    }>()
    ```

## 为 api 提供良好的类型提示

不要小看这个，ts 类型很容易，但想要用好，从而提高开发效率则不容易。

[arco-design-pro-vue]: https://github.com/arco-design/arco-design-pro-vue
