# 笔记

TODO:

- [x] 使用 token
- [ ] 使用 session

## 问题类型

- `input-content` 主观：提供输入框给用户输入
- `single-select` 单选题
- `multi-select` 多选题

## 自问自答

- bug: 为什么根据 v-for 渲染列表时，vue 总在最后插入元素，明明我是使用 splice 在中间插入一个新元素。

场景：想要根据一个数组 question_arr 响应式渲染若干个 question 元素。
此时，如果你使用下标，或者使用元素中的 order 作为 key 的话，那么当你在中间插入一个元素时，
vue 只会认为你在最后添加了一个新元素，所以只在最后面新建一个结点，而不是在中间新建一个结点。
所以，对于会改变顺序的列表，不要使用下标作为 key！

- 封装 axios 的目的所在

在对 axios 进行封装，目的是为了统一所有请求的数据，不管请求是成功也好，失败（比如断网）也罢，最终返回的都是一个统一的对象。也就是说，组件在调用这些请求 api 时，不需要考虑该 api 可能抛出错误，从而让组件代码编写更加方便。

<!-- 思考：应该将服务端中的未知错误，在 axios 中统一捕获？

但 vue 中始终是需要处理错误的，那么可以提供一个未知错误类型，当出现位置错误时，由 axios 进行处理，然后封装好信息返回给 vue 组件的使用，然后每个 vue 组件在使用 api 之前，都应该先判断一下是否是未知错误？这样子似乎很有很多重复代码！

那这样子。后端开发中，想要捕获所以错误的目的是不让程序因为报错而直接奔溃，但前端不存在这个问题。前端中捕获错误的目的是为了给用户友好的提示。所以可以直接在 axios 中提供友好的用户提示（借助 element-plus 的 message）。但问题是，前端中的代码始终是需要往下执行的，所以即使在 axios 中统一捕获错误了，而且给出友好提示了，那么 vue 中的代码还是需要判断一下是否有返回值，这不也算是重复的代码吗？

也许可以新建一个工具类，前端 vue 中需要调用 api 时，使用通过这个工具类来调用，这样能够保证前端的代码中只需要对理想情况进行负责。 -->

## 规范

代码问题（未确定）

- 对 api 的处理，相关错误处理应该直接在 vue 文件中。
- 对于异步操作，同时使用 async + await
- 组件之间的事件传递中，始终使用一个对象。也就是下面这样
    ```ts
    defineEmits<{
        (e: 'event', payload: {...}): void
    }>()
    ```
风格问题：

- vue 中间中，事件处理函数统一使用 evt 开头。比如按钮点击事件

## 为 api 提供良好的类型提示

不要小看这个，ts 类型很容易，但想要用好，从而提高开发效率则不容易。
