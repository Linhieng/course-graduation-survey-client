# 笔记

TODO:

- [x] 使用 token
- [ ] ~~使用 session~~ 使用 localSotrage 存储 token，然后使用 axios 拦截，在每次请求前填充 token，具体细节参考 [arco-design-pro-vue]
- [ ] 使用 pinia 进行单个页面的全局管理，不在组件中进行通信
- [ ] 修复相关样式问题（优先级低）
- [ ] 重构代码，让其逻辑更加清晰
- [ ] 重构类型，让其更易读（优先级极低，且需要考虑的事情极多！）
- [x] 拆分SurveyQuestion 类型 A|B
- [ ] 提供 dev 环境下的内容输出
- [x] 将文本编辑框抽离处理，与 store 解耦
- [ ] 对问题的增删，抽离到一个 NewOptions 组件中
- [ ] 重命名相关组件名称，让其更易读和有规律。
- [x] 处理问卷的缓存
- [ ] 提供对 PC 端的宽度适应，比如让工具直接显示在一旁，无需隐藏，但在 phone 中就隐藏为按钮
- [ ] 重新封装 axios，参考 [arco-design-pro-vue] 中的封装方式，使用拦截器进行封装！




## 自问自答

- 思考：完成必选校验后，如何搭配提交

每个组件自己负责自己的必选问题，然后将情况报告给 store。这种方式实现起来脉络清晰，而且也不容易出错。
但这仅仅是校验，当单纯提交时，如果校验成功，该如何处理呢？

这本应该是一个很简单的问题，用户点击 --> 校验 --> 成功则提交。

但现在变得有些复杂了，原因在于“校验”这一步变成了异步的！而且每一个问题都是独自进行校验。
你需要在什么时候才能够知道所有问题都校验成功了呢？

如果继续朝着“判断何时才算校验结束”这个方向思考，那么问题就会变得复杂，但如果换个角度思考，就简单了。
异步的复杂，那我们换成同步的不就可以了！

这个时候你可能就想掀起桌子骂人了，刚刚还在用异步校验必选呢？
你这又打算变成同步？那校验不就变得复杂了吗？

非也非也，只要消耗一点性能，那么就可以让问题变得简单！我们可以在 store 中进行一个总体的校验，当遇到一个
还没有添加答案的问题时，就调用 checkAnswer，将剩下的校验工作交给组件们自己去处理。而如果一路校验通畅，
那么就可以直接提交了！

这场景像极了班主任，班主任要提交班级作业时，首先她会自己先一份一份检查，而如果一旦发现有一份不合格，那么她就直接
全部打回，让全部同学重新检查一遍！而如果没有问题，那就不需要打回，直接就提交了！

妙呀妙呀，我都佩服我自己！可以看出我进步了，思维更灵活了。因为以前做问题系统时，这一块可是很让我束手无措的。当时
的思路一点也不清晰。

- 思考：填写问卷时，如何进行必选校验

为什么要思考这个呢？因为我的添加问卷界面同样分了很多组件，每一类问题都由一个特定的组件进行渲染。
这种开发方式让我很容易理解 DOM 结构树，而且我相信别人看到我这代码时，也会很容易理解 DOM 的结构。

但问题就在于，DOM 是划分的好了，但是表单校验是一个问题！

抽象上看，整体的流程是这样的：
1. 用户点击提交
2. js 校验哪些必选的问题没有填写
3. js 通知用户某些问题没有添加，同时，还应该能够让页面滚动到对应位置

目前，先不考虑滚动问题，先确保问题的必选。由于前面的经验，一个页面的数据我会将它全部交给
store 进行统一管理，所以，当点击提交时，也应该由 store 进行统一管理，同时进行数据的校验。
但发现每个问题没有内容时，就应该能够通过某种方式通知到对应的组件。

我觉得这里应该使用广播的时候，也就是说，store 会将还未添加的问题的 id 进行广播。
然后每个组件都会接收这个广播，然后看看是不是自己的锅。如果是，那么该组件就应该以某种方式提醒用户。
组件通知的方式可以通过弹出一个消息来实现。

但如果有很多问题，用户全部都没添加，那此时岂不是会弹出非常非常多的消息？所以这种方式不可取。
虽然可以想到用优先级处理，也就是当有一个组件弹出消息后，那么其他组件就不能弹出消息了。
但这种方式方式我觉得有点复杂了，杀鸡焉用牛刀。

算了，先不想那么多，总之，现在应该先实现一个机制，让组件能够知道当前它所负责的问题还未被添加。

其实，除了让 store 广播 id 外，还有一种方式能够实现：那就是发送一个提交事件给所有组件，然后
每个组件自己进行内容是否已经填写。如果未填写，则通知用户，同时也将这个消息报告给 store。
而 store 就能够收到所有还未填写的组件，然后实际的消息也由 store 负责发布。

经过上面的思考，这个过程其实和现实的很多地方是很像的。store 就是中枢，每一个组件就是对应的底层。

- 聊聊 element-plus

可以说，使用 vue 进行开发，很大程度上是为了使用 vue 的相关生态，而不是使用 vue。
element-plus 就是其中最重要的一个生态之一。目前看来，我对 element-plus 的最主要需求其实是：

- msg 和 notice，这两个可以将 log 信息直接显示给用户。
- 表单相关组件，比如输入框，开关等，虽然有问题，但相比自己开发还是快了很多。

- vue 开发的痛点

vue 注意提供了组件化开发，组件化开发对于页面样式的划分很有用，但是每个组件之间的数据通信则变得复杂起来了。
比如一个创建问卷的页面，目前的页面内容其实很简单，但里面却包含了 10 个以上的组件，单纯从 UI 上来看，组件
划分地越多，其实并不影响什么，甚至有利于阅读，但一旦设计到数据，那就变得很复杂了。

原本，这一个页面上只需要一个总的 survey 对象，其他的所有页面模块都是对 survey 中的每一部分进行操作，
这个时候完全不需要考虑同步异步问题，但使用了 vue 后，这一个 survey 就变得七零八碎了。

所以，后续的工作应该是优化这一块内容，目前这一块内容还存在许多 bug，级别都是数据通信之间惹的祸。

具体的解决方案，目前我的想法时，统一使用 pinia 进行管理，虽然这还是有些复杂，但至少能给减少 bug 的存在。
当然，一切还得实践后才知晓答案。

- bug: 为什么根据 v-for 渲染列表时，vue 总在最后插入元素，明明我是使用 splice 在中间插入一个新元素。

场景：想要根据一个数组 question_arr 响应式渲染若干个 question 元素。
此时，如果你使用下标，或者使用元素中的 order 作为 key 的话，那么当你在中间插入一个元素时，
vue 只会认为你在最后添加了一个新元素，所以只在最后面新建一个结点，而不是在中间新建一个结点。
所以，对于会改变顺序的列表，不要使用下标作为 key！

- 封装 axios 的目的所在

在对 axios 进行封装，目的是为了统一所有请求的数据，不管请求是成功也好，失败（比如断网）也罢，最终返回的都是一个统一的对象。也就是说，组件在调用这些请求 api 时，不需要考虑该 api 可能抛出错误，从而让组件代码编写更加方便。

<!-- 思考：应该将服务端中的未知错误，在 axios 中统一捕获？

但 vue 中始终是需要处理错误的，那么可以提供一个未知错误类型，当出现位置错误时，由 axios 进行处理，然后封装好信息返回给 vue 组件的使用，然后每个 vue 组件在使用 api 之前，都应该先判断一下是否是未知错误？这样子似乎很有很多重复代码！

那这样子。后端开发中，想要捕获所以错误的目的是不让程序因为报错而直接奔溃，但前端不存在这个问题。前端中捕获错误的目的是为了给用户友好的提示。所以可以直接在 axios 中提供友好的用户提示（借助 element-plus 的 message）。但问题是，前端中的代码始终是需要往下执行的，所以即使在 axios 中统一捕获错误了，而且给出友好提示了，那么 vue 中的代码还是需要判断一下是否有返回值，这不也算是重复的代码吗？

也许可以新建一个工具类，前端 vue 中需要调用 api 时，使用通过这个工具类来调用，这样能够保证前端的代码中只需要对理想情况进行负责。 -->

## 规范

代码问题（未确定）

- 对 api 的处理，相关错误处理应该直接在 vue 文件中。
- 对于异步操作，同时使用 async + await
- 组件之间的事件传递中，始终使用一个对象。也就是下面这样
    ```ts
    defineEmits<{
        (e: 'event', payload: {...}): void
    }>()
    ```

## 为 api 提供良好的类型提示

不要小看这个，ts 类型很容易，但想要用好，从而提高开发效率则不容易。

[arco-design-pro-vue]: https://github.com/arco-design/arco-design-pro-vue
